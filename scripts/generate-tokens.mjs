import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const rootDir = path.resolve(__dirname, '..');

const tokensPath = path.join(rootDir, 'public', 'figma-tokens.json');
const generatedDir = path.join(rootDir, 'src', 'styles', 'generated');
const themesDir = path.join(rootDir, 'src', 'styles', 'themes');

const weightMap = new Map([
	['light', '300'],
	['regular', '400'],
	['medium', '500'],
	['semi bold', '600'],
	['semi-bold', '600'],
	['bold', '700'],
	['extra bold', '800'],
	['extra-bold', '800'],
]);

const normalizeSegment = (segment) => {
	const normalized = segment
		.replace(/%/g, 'percent')
		.replace(/[^\w\s-]/g, '')
		.replace(/_/g, '-')
		.replace(/\s+/g, '-')
		.toLowerCase()
		.replace(/colour/g, 'color');

	return normalized.replace(/-+/g, '-');
};

const toVarName = (pathParts) =>
	pathParts.map((segment) => normalizeSegment(segment)).join('-');

const isTokenLeaf = (node) =>
	Boolean(node && typeof node === 'object' && 'value' in node && 'type' in node);

const getTokenByPath = (tokenSet, pathParts) => {
	let node = tokenSet;
	for (const part of pathParts) {
		if (!node || typeof node !== 'object' || !(part in node)) {
			return null;
		}
		node = node[part];
	}
	return isTokenLeaf(node) ? node : null;
};

const resolveReference = (ref, tokenSets, searchOrder, seen) => {
	const pathParts = ref.split('.');
	const key = `${searchOrder.join('|')}::${ref}`;
	if (seen.has(key)) {
		throw new Error(`Circular token reference: ${ref}`);
	}

	seen.add(key);
	for (const setName of searchOrder) {
		const tokenSet = tokenSets[setName];
		if (!tokenSet) continue;
		const token = getTokenByPath(tokenSet, pathParts);
		if (!token) continue;

		if (typeof token.value === 'string') {
			const match = token.value.match(/^\{(.+)\}$/);
			if (match) {
				return resolveReference(match[1], tokenSets, searchOrder, seen);
			}
		}

		return token;
	}

	throw new Error(`Unable to resolve token reference: ${ref}`);
};

const formatValue = (value, type, pathParts) => {
	if (type === 'number') {
		return `${value}px`;
	}

	if (type === 'text') {
		if (typeof value === 'string') {
			const lower = value.trim().toLowerCase();
			const pathKey = pathParts.map((part) => part.toLowerCase()).join(' ');
			if (pathKey.includes('font weight') || pathKey.includes('font-weight')) {
				const mappedWeight = weightMap.get(lower);
				return mappedWeight ?? value;
			}

			const needsQuotes = /[\s,]/.test(value) && !/^["'].*["']$/.test(value);
			return needsQuotes ? `"${value}"` : value;
		}
	}

	return value;
};

const flattenTokens = (node, pathParts = [], output = []) => {
	if (!node || typeof node !== 'object') return output;

	if (isTokenLeaf(node)) {
		output.push({ pathParts, token: node });
		return output;
	}

	for (const [key, value] of Object.entries(node)) {
		flattenTokens(value, [...pathParts, key], output);
	}

	return output;
};

const generateCssBlock = (tokens, tokenSets, searchOrder, selector) => {
	const lines = [];
	for (const { pathParts, token } of tokens) {
		const value = token.value;
		let resolved = token;
		if (typeof value === 'string') {
			const match = value.match(/^\{(.+)\}$/);
			if (match) {
				resolved = resolveReference(match[1], tokenSets, searchOrder, new Set());
			}
		}

		const varName = `--${toVarName(pathParts)}`;
		const formatted = formatValue(resolved.value, resolved.type, pathParts);
		lines.push(`\t${varName}: ${formatted};`);
	}

	return `${selector} {\n${lines.join('\n')}\n}\n`;
};

const run = async () => {
	const rawTokens = await fs.readFile(tokensPath, 'utf8');
	const tokenData = JSON.parse(rawTokens);

	const tokenSets = Object.fromEntries(
		Object.entries(tokenData).filter(([key]) => !key.startsWith('$')),
	);

	const brandASearchOrder = [
		'Mapped/BrandA',
		'Alias colours/BrandA',
		'Primitives/Default',
	];

	const brandBSearchOrder = [
		'Mapped/BrandB',
		'Alias colours/BrandB',
		'Primitives/Default',
	];

	const responsiveDesktopOrder = ['Responsive/Desktop', 'Primitives/Default'];
	const responsiveMobileOrder = ['Responsive/Mobile', 'Primitives/Default'];

	const brandATokens = flattenTokens(tokenSets['Mapped/BrandA'] ?? {});
	const brandBTokens = flattenTokens(tokenSets['Mapped/BrandB'] ?? {});
	const responsiveDesktopTokens = flattenTokens(
		tokenSets['Responsive/Desktop'] ?? {},
	);
	const responsiveMobileTokens = flattenTokens(
		tokenSets['Responsive/Mobile'] ?? {},
	);

	const generatedHeader =
		'/* Generated by scripts/generate-tokens.mjs. Do not edit by hand. */\n';

	const responsiveCss = [
		generatedHeader,
		generateCssBlock(
			responsiveDesktopTokens,
			tokenSets,
			responsiveDesktopOrder,
			':root',
		),
		'@media (max-width: 639px) {\n' +
			generateCssBlock(
				responsiveMobileTokens,
				tokenSets,
				responsiveMobileOrder,
				':root',
			) +
			'}\n',
	].join('\n');

	const brandACss = [
		generatedHeader,
		generateCssBlock(
			brandATokens,
			tokenSets,
			brandASearchOrder,
			':root, :root[data-theme="brand-a"]',
		),
	].join('\n');

	const brandBCss = [
		generatedHeader,
		generateCssBlock(
			brandBTokens,
			tokenSets,
			brandBSearchOrder,
			':root[data-theme="brand-b"]',
		),
	].join('\n');

	await fs.mkdir(generatedDir, { recursive: true });
	await fs.mkdir(themesDir, { recursive: true });

	await Promise.all([
		fs.writeFile(path.join(generatedDir, 'design-tokens.css'), responsiveCss),
		fs.writeFile(path.join(themesDir, 'brand-a.css'), brandACss),
		fs.writeFile(path.join(themesDir, 'brand-b.css'), brandBCss),
	]);
};

run().catch((error) => {
	console.error(error);
	process.exit(1);
});
